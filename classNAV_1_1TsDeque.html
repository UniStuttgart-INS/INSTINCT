<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.12.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>INSTINCT: NAV::TsDeque&lt; T, Alloc &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams','[tex]/color','[tex]/colortbl']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams','color','colortbl']
  }
};
window.MathJax = {
    tex: {
        tags: 'ams'
    }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <!--Doxygen Awesome Theme related settings:-->
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeTabs.init()
  </script>
  <!--End of Doxygen Awesome settings-->
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="INSTINCT_Logo_Text.png"  /></td>
              <td id="projectalign">
                <div id="projectname"><span
                    id="projectnumber">&#160;0.3.0</span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classNAV_1_1TsDeque.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classNAV_1_1TsDeque-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NAV::TsDeque&lt; T, Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Thread-safe deque.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b35f9463dffbc0024519d030e454ce2" id="r_a9b35f9463dffbc0024519d030e454ce2"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9b35f9463dffbc0024519d030e454ce2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b35f9463dffbc0024519d030e454ce2">assign</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9b35f9463dffbc0024519d030e454ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this.  <br /></td></tr>
<tr class="separator:a9b35f9463dffbc0024519d030e454ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b64f1d43706fc6b6cca3473a332d1e8" id="r_a5b64f1d43706fc6b6cca3473a332d1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b64f1d43706fc6b6cca3473a332d1e8">assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a5b64f1d43706fc6b6cca3473a332d1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list ilist.  <br /></td></tr>
<tr class="separator:a5b64f1d43706fc6b6cca3473a332d1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be94f59bc1648c3796e2cc9b1ca6f03" id="r_a1be94f59bc1648c3796e2cc9b1ca6f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be94f59bc1648c3796e2cc9b1ca6f03">assign</a> (typename std::deque&lt; T, Alloc &gt;::size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a1be94f59bc1648c3796e2cc9b1ca6f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with count copies of value value.  <br /></td></tr>
<tr class="separator:a1be94f59bc1648c3796e2cc9b1ca6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5047f3cbaa74c124ad57763d12dd926a" id="r_a5047f3cbaa74c124ad57763d12dd926a"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5047f3cbaa74c124ad57763d12dd926a">at</a> (typename std::deque&lt; T, Alloc &gt;::size_type pos)</td></tr>
<tr class="memdesc:a5047f3cbaa74c124ad57763d12dd926a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type std::out_of_range is thrown.  <br /></td></tr>
<tr class="separator:a5047f3cbaa74c124ad57763d12dd926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aabb4ac4badd7364c466a333a157ad8" id="r_a7aabb4ac4badd7364c466a333a157ad8"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aabb4ac4badd7364c466a333a157ad8">at</a> (typename std::deque&lt; T, Alloc &gt;::size_type pos) const</td></tr>
<tr class="memdesc:a7aabb4ac4badd7364c466a333a157ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type std::out_of_range is thrown.  <br /></td></tr>
<tr class="separator:a7aabb4ac4badd7364c466a333a157ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b839d7218998c9be19292a8ae6d7418" id="r_a1b839d7218998c9be19292a8ae6d7418"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b839d7218998c9be19292a8ae6d7418">back</a> ()</td></tr>
<tr class="memdesc:a1b839d7218998c9be19292a8ae6d7418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a1b839d7218998c9be19292a8ae6d7418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b661a37731e6d908330d6c3567acc97" id="r_a7b661a37731e6d908330d6c3567acc97"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b661a37731e6d908330d6c3567acc97">back</a> () const</td></tr>
<tr class="memdesc:a7b661a37731e6d908330d6c3567acc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <br /></td></tr>
<tr class="separator:a7b661a37731e6d908330d6c3567acc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a20f23f8b306b628c1a9fbf1854167f" id="r_a0a20f23f8b306b628c1a9fbf1854167f"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a20f23f8b306b628c1a9fbf1854167f">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a0a20f23f8b306b628c1a9fbf1854167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>.  <br /></td></tr>
<tr class="separator:a0a20f23f8b306b628c1a9fbf1854167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc66a0d8b5b36af158f638e7ae005d" id="r_a3ebc66a0d8b5b36af158f638e7ae005d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d">begin</a> () noexcept</td></tr>
<tr class="memdesc:a3ebc66a0d8b5b36af158f638e7ae005d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>.  <br /></td></tr>
<tr class="separator:a3ebc66a0d8b5b36af158f638e7ae005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb65257d718177770c6e984ae1e5536d" id="r_aeb65257d718177770c6e984ae1e5536d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb65257d718177770c6e984ae1e5536d">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aeb65257d718177770c6e984ae1e5536d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>.  <br /></td></tr>
<tr class="separator:aeb65257d718177770c6e984ae1e5536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45b9c1144dea9daca1501945c9ba9c" id="r_a9b45b9c1144dea9daca1501945c9ba9c"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b45b9c1144dea9daca1501945c9ba9c">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9b45b9c1144dea9daca1501945c9ba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a9b45b9c1144dea9daca1501945c9ba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848429f5c9243e7ba1e8c0754d100baf" id="r_a848429f5c9243e7ba1e8c0754d100baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848429f5c9243e7ba1e8c0754d100baf">clear</a> () noexcept</td></tr>
<tr class="separator:a848429f5c9243e7ba1e8c0754d100baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafe1c3f2888cc0dcaf2ab27a2ca1227" id="r_abafe1c3f2888cc0dcaf2ab27a2ca1227"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abafe1c3f2888cc0dcaf2ab27a2ca1227">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:abafe1c3f2888cc0dcaf2ab27a2ca1227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>.  <br /></td></tr>
<tr class="separator:abafe1c3f2888cc0dcaf2ab27a2ca1227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c0c4299bf1c5424ff0218dc303117" id="r_af56c0c4299bf1c5424ff0218dc303117"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af56c0c4299bf1c5424ff0218dc303117">crend</a> () const noexcept</td></tr>
<tr class="memdesc:af56c0c4299bf1c5424ff0218dc303117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:af56c0c4299bf1c5424ff0218dc303117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f60eb6b8b1af75670ae82b95447b2" id="r_ac57f60eb6b8b1af75670ae82b95447b2"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac57f60eb6b8b1af75670ae82b95447b2"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac57f60eb6b8b1af75670ae82b95447b2">emplace</a> (typename std::deque&lt; T &gt;::const_iterator pos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac57f60eb6b8b1af75670ae82b95447b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container directly before pos.  <br /></td></tr>
<tr class="separator:ac57f60eb6b8b1af75670ae82b95447b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543910d3ec0189473a7143a65b5d55c" id="r_a1543910d3ec0189473a7143a65b5d55c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1543910d3ec0189473a7143a65b5d55c"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1543910d3ec0189473a7143a65b5d55c">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1543910d3ec0189473a7143a65b5d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container.  <br /></td></tr>
<tr class="separator:a1543910d3ec0189473a7143a65b5d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbea375bf1b74058cd23ead6546a887d" id="r_abbea375bf1b74058cd23ead6546a887d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abbea375bf1b74058cd23ead6546a887d"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbea375bf1b74058cd23ead6546a887d">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abbea375bf1b74058cd23ead6546a887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element to the beginning of the container.  <br /></td></tr>
<tr class="separator:abbea375bf1b74058cd23ead6546a887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a05e1a6943bb88e7546be8e4695606" id="r_ae3a05e1a6943bb88e7546be8e4695606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a05e1a6943bb88e7546be8e4695606">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ae3a05e1a6943bb88e7546be8e4695606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether '<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a> == <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>'.  <br /></td></tr>
<tr class="separator:ae3a05e1a6943bb88e7546be8e4695606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f75120b51cd0c5a971961a8165771d" id="r_ae9f75120b51cd0c5a971961a8165771d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9f75120b51cd0c5a971961a8165771d">end</a> () const noexcept</td></tr>
<tr class="memdesc:ae9f75120b51cd0c5a971961a8165771d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ae9f75120b51cd0c5a971961a8165771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fb879559cb663986f4aab58e4d8a13" id="r_ad5fb879559cb663986f4aab58e4d8a13"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13">end</a> () noexcept</td></tr>
<tr class="memdesc:ad5fb879559cb663986f4aab58e4d8a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:ad5fb879559cb663986f4aab58e4d8a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9697e748256d9a8b2ee43f7b8ef606" id="r_aeb9697e748256d9a8b2ee43f7b8ef606"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb9697e748256d9a8b2ee43f7b8ef606">erase</a> (typename std::deque&lt; T &gt;::const_iterator first, typename std::deque&lt; T &gt;::const_iterator last)</td></tr>
<tr class="memdesc:aeb9697e748256d9a8b2ee43f7b8ef606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last). All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.  <br /></td></tr>
<tr class="separator:aeb9697e748256d9a8b2ee43f7b8ef606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43754c6e04ad136086d50b2ba0611c1" id="r_ae43754c6e04ad136086d50b2ba0611c1"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43754c6e04ad136086d50b2ba0611c1">erase</a> (typename std::deque&lt; T &gt;::const_iterator pos)</td></tr>
<tr class="memdesc:ae43754c6e04ad136086d50b2ba0611c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <br /></td></tr>
<tr class="separator:ae43754c6e04ad136086d50b2ba0611c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79acf8736f97723df0081a8610a376f" id="r_ad79acf8736f97723df0081a8610a376f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad79acf8736f97723df0081a8610a376f">extract_front</a> ()</td></tr>
<tr class="memdesc:ad79acf8736f97723df0081a8610a376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the first element in the container and removes it from the container.  <br /></td></tr>
<tr class="separator:ad79acf8736f97723df0081a8610a376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb005d6c17251ece8b9c4ad2835bd3ec" id="r_abb005d6c17251ece8b9c4ad2835bd3ec"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb005d6c17251ece8b9c4ad2835bd3ec">front</a> ()</td></tr>
<tr class="memdesc:abb005d6c17251ece8b9c4ad2835bd3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:abb005d6c17251ece8b9c4ad2835bd3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178dc03c9f4c0e95855e59bec49475f8" id="r_a178dc03c9f4c0e95855e59bec49475f8"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a178dc03c9f4c0e95855e59bec49475f8">front</a> () const</td></tr>
<tr class="memdesc:a178dc03c9f4c0e95855e59bec49475f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <br /></td></tr>
<tr class="separator:a178dc03c9f4c0e95855e59bec49475f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a1c1f027480466bf15561937943683" id="r_af6a1c1f027480466bf15561937943683"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T, Alloc &gt;::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a1c1f027480466bf15561937943683">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:af6a1c1f027480466bf15561937943683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <br /></td></tr>
<tr class="separator:af6a1c1f027480466bf15561937943683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84eb1be1822ff509d78e70c35e5376f" id="r_aa84eb1be1822ff509d78e70c35e5376f"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa84eb1be1822ff509d78e70c35e5376f">insert</a> (typename std::deque&lt; T &gt;::const_iterator pos, const T &amp;value)</td></tr>
<tr class="memdesc:aa84eb1be1822ff509d78e70c35e5376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert value before pos in the container.  <br /></td></tr>
<tr class="separator:aa84eb1be1822ff509d78e70c35e5376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35844694b10a63ba7d26367acee40314" id="r_a35844694b10a63ba7d26367acee40314"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a35844694b10a63ba7d26367acee40314"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a35844694b10a63ba7d26367acee40314">insert</a> (typename std::deque&lt; T &gt;::const_iterator pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a35844694b10a63ba7d26367acee40314"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from range [first, last) before pos.  <br /></td></tr>
<tr class="separator:a35844694b10a63ba7d26367acee40314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3364ffb541afb2a223c986f82989a08e" id="r_a3364ffb541afb2a223c986f82989a08e"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3364ffb541afb2a223c986f82989a08e">insert</a> (typename std::deque&lt; T &gt;::const_iterator pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a3364ffb541afb2a223c986f82989a08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer list ilist before pos.  <br /></td></tr>
<tr class="separator:a3364ffb541afb2a223c986f82989a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa60b369f88913334fee7216c2bed7" id="r_a7eaa60b369f88913334fee7216c2bed7"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eaa60b369f88913334fee7216c2bed7">insert</a> (typename std::deque&lt; T &gt;::const_iterator pos, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a7eaa60b369f88913334fee7216c2bed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert value before pos in the container.  <br /></td></tr>
<tr class="separator:a7eaa60b369f88913334fee7216c2bed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad343eee2f38da261ef3d10d6f050dc79" id="r_ad343eee2f38da261ef3d10d6f050dc79"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad343eee2f38da261ef3d10d6f050dc79">insert</a> (typename std::deque&lt; T &gt;::const_iterator pos, typename std::deque&lt; T, Alloc &gt;::size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:ad343eee2f38da261ef3d10d6f050dc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts count copies of the value before pos  <br /></td></tr>
<tr class="separator:ad343eee2f38da261ef3d10d6f050dc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea171afc682e3a08588161e2a0843867" id="r_aea171afc682e3a08588161e2a0843867"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T, Alloc &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea171afc682e3a08588161e2a0843867">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:aea171afc682e3a08588161e2a0843867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a>, <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>) for the largest container.  <br /></td></tr>
<tr class="separator:aea171afc682e3a08588161e2a0843867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae050b36a19f7c0abfe47e08a6c8e6400" id="r_ae050b36a19f7c0abfe47e08a6c8e6400"><td class="memItemLeft" align="right" valign="top"><a id="ae050b36a19f7c0abfe47e08a6c8e6400" name="ae050b36a19f7c0abfe47e08a6c8e6400"></a>
<a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;other)</td></tr>
<tr class="memdesc:ae050b36a19f7c0abfe47e08a6c8e6400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:ae050b36a19f7c0abfe47e08a6c8e6400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fbf6fe3a38fa6a792e3f0f39edfa90" id="r_a43fbf6fe3a38fa6a792e3f0f39edfa90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43fbf6fe3a38fa6a792e3f0f39edfa90">operator=</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a43fbf6fe3a38fa6a792e3f0f39edfa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:a43fbf6fe3a38fa6a792e3f0f39edfa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7e8bec34c18dc84af0ccbd1e771066" id="r_a4d7e8bec34c18dc84af0ccbd1e771066"><td class="memItemLeft" align="right" valign="top"><a id="a4d7e8bec34c18dc84af0ccbd1e771066" name="a4d7e8bec34c18dc84af0ccbd1e771066"></a>
<a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4d7e8bec34c18dc84af0ccbd1e771066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a4d7e8bec34c18dc84af0ccbd1e771066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6914fc1ff4b396561a3592460783b1b" id="r_ac6914fc1ff4b396561a3592460783b1b"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6914fc1ff4b396561a3592460783b1b">operator[]</a> (typename std::deque&lt; T, Alloc &gt;::size_type pos)</td></tr>
<tr class="memdesc:ac6914fc1ff4b396561a3592460783b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos. No bounds checking is performed.  <br /></td></tr>
<tr class="separator:ac6914fc1ff4b396561a3592460783b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300be1eff93c23155acb254723923267" id="r_a300be1eff93c23155acb254723923267"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300be1eff93c23155acb254723923267">operator[]</a> (typename std::deque&lt; T, Alloc &gt;::size_type pos) const</td></tr>
<tr class="memdesc:a300be1eff93c23155acb254723923267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos. No bounds checking is performed.  <br /></td></tr>
<tr class="separator:a300be1eff93c23155acb254723923267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c3cbb94e25d44b4b3b7a9ca8f202a" id="r_a962c3cbb94e25d44b4b3b7a9ca8f202a"><td class="memItemLeft" align="right" valign="top"><a id="a962c3cbb94e25d44b4b3b7a9ca8f202a" name="a962c3cbb94e25d44b4b3b7a9ca8f202a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a962c3cbb94e25d44b4b3b7a9ca8f202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container. <br /></td></tr>
<tr class="separator:a962c3cbb94e25d44b4b3b7a9ca8f202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede28acd1d2e912285c208d18ba93e59" id="r_aede28acd1d2e912285c208d18ba93e59"><td class="memItemLeft" align="right" valign="top"><a id="aede28acd1d2e912285c208d18ba93e59" name="aede28acd1d2e912285c208d18ba93e59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="memdesc:aede28acd1d2e912285c208d18ba93e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element of the container. If there are no elements in the container, the behavior is undefined. <br /></td></tr>
<tr class="separator:aede28acd1d2e912285c208d18ba93e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778844411c23c3d73076378e3109dc30" id="r_a778844411c23c3d73076378e3109dc30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778844411c23c3d73076378e3109dc30">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a778844411c23c3d73076378e3109dc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container. The new element is initialized as a copy of value.  <br /></td></tr>
<tr class="separator:a778844411c23c3d73076378e3109dc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0492b2b65617d4d154fec0b9e8b74a" id="r_afe0492b2b65617d4d154fec0b9e8b74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe0492b2b65617d4d154fec0b9e8b74a">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:afe0492b2b65617d4d154fec0b9e8b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container. Value is moved into the new element.  <br /></td></tr>
<tr class="separator:afe0492b2b65617d4d154fec0b9e8b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007912678085d5fb1ee75f6e7555770d" id="r_a007912678085d5fb1ee75f6e7555770d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007912678085d5fb1ee75f6e7555770d">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a007912678085d5fb1ee75f6e7555770d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value. All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.  <br /></td></tr>
<tr class="separator:a007912678085d5fb1ee75f6e7555770d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747df6b5d743ccadd700b8278aee33c6" id="r_a747df6b5d743ccadd700b8278aee33c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a747df6b5d743ccadd700b8278aee33c6">push_front</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a747df6b5d743ccadd700b8278aee33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given element value to the beginning of the container. Value is moved into the new element. All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.  <br /></td></tr>
<tr class="separator:a747df6b5d743ccadd700b8278aee33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cacc4eaa6e8fa6ccd58429c5126e40d" id="r_a4cacc4eaa6e8fa6ccd58429c5126e40d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cacc4eaa6e8fa6ccd58429c5126e40d">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a4cacc4eaa6e8fa6ccd58429c5126e40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>.  <br /></td></tr>
<tr class="separator:a4cacc4eaa6e8fa6ccd58429c5126e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca6b19069d2677fa95c39750acdd5d" id="r_a25ca6b19069d2677fa95c39750acdd5d"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ca6b19069d2677fa95c39750acdd5d">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:a25ca6b19069d2677fa95c39750acdd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>.  <br /></td></tr>
<tr class="separator:a25ca6b19069d2677fa95c39750acdd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c83700b495b7512b8a059647d3e2847" id="r_a7c83700b495b7512b8a059647d3e2847"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c83700b495b7512b8a059647d3e2847">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a7c83700b495b7512b8a059647d3e2847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a7c83700b495b7512b8a059647d3e2847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18418e08e214ac9ccabe7ee0a59411dd" id="r_a18418e08e214ac9ccabe7ee0a59411dd"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T &gt;::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd">rend</a> () noexcept</td></tr>
<tr class="memdesc:a18418e08e214ac9ccabe7ee0a59411dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a18418e08e214ac9ccabe7ee0a59411dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30474793b611d738230ffa00a90fe2f8" id="r_a30474793b611d738230ffa00a90fe2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30474793b611d738230ffa00a90fe2f8">resize</a> (typename std::deque&lt; T, Alloc &gt;::size_type count)</td></tr>
<tr class="memdesc:a30474793b611d738230ffa00a90fe2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <br /></td></tr>
<tr class="separator:a30474793b611d738230ffa00a90fe2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4515d81a5c7f996d3526f8469b70346e" id="r_a4515d81a5c7f996d3526f8469b70346e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4515d81a5c7f996d3526f8469b70346e">resize</a> (typename std::deque&lt; T, Alloc &gt;::size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a4515d81a5c7f996d3526f8469b70346e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain count elements.  <br /></td></tr>
<tr class="separator:a4515d81a5c7f996d3526f8469b70346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6262cc399ed9641264ea8f7cd7877ae6" id="r_a6262cc399ed9641264ea8f7cd7877ae6"><td class="memItemLeft" align="right" valign="top"><a id="a6262cc399ed9641264ea8f7cd7877ae6" name="a6262cc399ed9641264ea8f7cd7877ae6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink_to_fit</b> ()</td></tr>
<tr class="memdesc:a6262cc399ed9641264ea8f7cd7877ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity. <br /></td></tr>
<tr class="separator:a6262cc399ed9641264ea8f7cd7877ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe145d9a286457bea3825b0ce34d722" id="r_a6fe145d9a286457bea3825b0ce34d722"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T, Alloc &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fe145d9a286457bea3825b0ce34d722">size</a> () const noexcept</td></tr>
<tr class="memdesc:a6fe145d9a286457bea3825b0ce34d722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a>, <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>).  <br /></td></tr>
<tr class="separator:a6fe145d9a286457bea3825b0ce34d722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b04a5077600e9355e35e5b40f025241" id="r_a6b04a5077600e9355e35e5b40f025241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b04a5077600e9355e35e5b40f025241">swap</a> (std::deque&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a6b04a5077600e9355e35e5b40f025241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.  <br /></td></tr>
<tr class="separator:a6b04a5077600e9355e35e5b40f025241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a318a3806101bfa078d54244dcd9ee" id="r_ad5a318a3806101bfa078d54244dcd9ee"><td class="memItemLeft" align="right" valign="top"><a id="ad5a318a3806101bfa078d54244dcd9ee" name="ad5a318a3806101bfa078d54244dcd9ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TsDeque</b> ()=default</td></tr>
<tr class="memdesc:ad5a318a3806101bfa078d54244dcd9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. Constructs an empty container with a default-constructed allocator. <br /></td></tr>
<tr class="separator:ad5a318a3806101bfa078d54244dcd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5324786b181c7f8db0b0a816c895e59a" id="r_a5324786b181c7f8db0b0a816c895e59a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5324786b181c7f8db0b0a816c895e59a">TsDeque</a> (const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:a5324786b181c7f8db0b0a816c895e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator alloc.  <br /></td></tr>
<tr class="separator:a5324786b181c7f8db0b0a816c895e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b6963c159351c19f7203039c5d6e10" id="r_a97b6963c159351c19f7203039c5d6e10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b6963c159351c19f7203039c5d6e10">TsDeque</a> (const <a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;other)</td></tr>
<tr class="memdesc:a97b6963c159351c19f7203039c5d6e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <br /></td></tr>
<tr class="separator:a97b6963c159351c19f7203039c5d6e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8950dff21608d63ea80b95de1a200bf" id="r_ae8950dff21608d63ea80b95de1a200bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8950dff21608d63ea80b95de1a200bf">TsDeque</a> (const <a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;other, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:ae8950dff21608d63ea80b95de1a200bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the copy of the contents of other, using alloc as the allocator.  <br /></td></tr>
<tr class="separator:ae8950dff21608d63ea80b95de1a200bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e872dcdffd1a50359560e307bfc8b17" id="r_a3e872dcdffd1a50359560e307bfc8b17"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a3e872dcdffd1a50359560e307bfc8b17"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e872dcdffd1a50359560e307bfc8b17">TsDeque</a> (InputIt first, InputIt last, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:a3e872dcdffd1a50359560e307bfc8b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <br /></td></tr>
<tr class="separator:a3e872dcdffd1a50359560e307bfc8b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fff7e0c8999e1b500e24027c57556f" id="r_ab2fff7e0c8999e1b500e24027c57556f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2fff7e0c8999e1b500e24027c57556f">TsDeque</a> (std::initializer_list&lt; T &gt; init, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:ab2fff7e0c8999e1b500e24027c57556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <br /></td></tr>
<tr class="separator:ab2fff7e0c8999e1b500e24027c57556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021abfe15b74be29f747fcb6206aee3" id="r_a4021abfe15b74be29f747fcb6206aee3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4021abfe15b74be29f747fcb6206aee3">TsDeque</a> (<a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4021abfe15b74be29f747fcb6206aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other.  <br /></td></tr>
<tr class="separator:a4021abfe15b74be29f747fcb6206aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c63aef2a6f9eab3021d4680c8c6e4" id="r_aac6c63aef2a6f9eab3021d4680c8c6e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac6c63aef2a6f9eab3021d4680c8c6e4">TsDeque</a> (<a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp;&amp;other, const Alloc &amp;alloc) noexcept</td></tr>
<tr class="memdesc:aac6c63aef2a6f9eab3021d4680c8c6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move.  <br /></td></tr>
<tr class="separator:aac6c63aef2a6f9eab3021d4680c8c6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5075bb909fff6e5cfde4c0363e424d" id="r_a2f5075bb909fff6e5cfde4c0363e424d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f5075bb909fff6e5cfde4c0363e424d">TsDeque</a> (typename std::deque&lt; T, Alloc &gt;::size_type count, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:a2f5075bb909fff6e5cfde4c0363e424d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count default-inserted instances of T. No copies are made.  <br /></td></tr>
<tr class="separator:a2f5075bb909fff6e5cfde4c0363e424d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1b585a2b49400bf926518b65ba6504" id="r_aae1b585a2b49400bf926518b65ba6504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae1b585a2b49400bf926518b65ba6504">TsDeque</a> (typename std::deque&lt; T, Alloc &gt;::size_type count, const T &amp;value, const Alloc &amp;alloc=Alloc())</td></tr>
<tr class="memdesc:aae1b585a2b49400bf926518b65ba6504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <br /></td></tr>
<tr class="separator:aae1b585a2b49400bf926518b65ba6504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b1fdc687c81f4aa7196d3c4c7fa0d" id="r_a8a2b1fdc687c81f4aa7196d3c4c7fa0d"><td class="memItemLeft" align="right" valign="top"><a id="a8a2b1fdc687c81f4aa7196d3c4c7fa0d" name="a8a2b1fdc687c81f4aa7196d3c4c7fa0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TsDeque</b> ()=default</td></tr>
<tr class="memdesc:a8a2b1fdc687c81f4aa7196d3c4c7fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8a2b1fdc687c81f4aa7196d3c4c7fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0df79cbb657049bdcc8bdef5fa96a6d8" id="r_a0df79cbb657049bdcc8bdef5fa96a6d8"><td class="memItemLeft" align="right" valign="top"><a id="a0df79cbb657049bdcc8bdef5fa96a6d8" name="a0df79cbb657049bdcc8bdef5fa96a6d8"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>_mutex</b></td></tr>
<tr class="memdesc:a0df79cbb657049bdcc8bdef5fa96a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to interact with the queue object. <br /></td></tr>
<tr class="separator:a0df79cbb657049bdcc8bdef5fa96a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78fecbd59fe420301e458f97435446a" id="r_ab78fecbd59fe420301e458f97435446a"><td class="memItemLeft" align="right" valign="top"><a id="ab78fecbd59fe420301e458f97435446a" name="ab78fecbd59fe420301e458f97435446a"></a>
std::deque&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_queue</b></td></tr>
<tr class="memdesc:ab78fecbd59fe420301e458f97435446a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue with received data. <br /></td></tr>
<tr class="separator:ab78fecbd59fe420301e458f97435446a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class NAV::TsDeque&lt; T, Alloc &gt;</div><p>Thread-safe deque. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5324786b181c7f8db0b0a816c895e59a" name="a5324786b181c7f8db0b0a816c895e59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5324786b181c7f8db0b0a816c895e59a">&#9670;&#160;</a></span>TsDeque() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae1b585a2b49400bf926518b65ba6504" name="aae1b585a2b49400bf926518b65ba6504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1b585a2b49400bf926518b65ba6504">&#9670;&#160;</a></span>TsDeque() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The size of the container </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f5075bb909fff6e5cfde4c0363e424d" name="a2f5075bb909fff6e5cfde4c0363e424d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5075bb909fff6e5cfde4c0363e424d">&#9670;&#160;</a></span>TsDeque() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The size of the container </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e872dcdffd1a50359560e307bfc8b17" name="a3e872dcdffd1a50359560e307bfc8b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e872dcdffd1a50359560e307bfc8b17">&#9670;&#160;</a></span>TsDeque() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First element of the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>Last element the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97b6963c159351c19f7203039c5d6e10" name="a97b6963c159351c19f7203039c5d6e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b6963c159351c19f7203039c5d6e10">&#9670;&#160;</a></span>TsDeque() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a>&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8950dff21608d63ea80b95de1a200bf" name="ae8950dff21608d63ea80b95de1a200bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8950dff21608d63ea80b95de1a200bf">&#9670;&#160;</a></span>TsDeque() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a>&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the copy of the contents of other, using alloc as the allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4021abfe15b74be29f747fcb6206aee3" name="a4021abfe15b74be29f747fcb6206aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4021abfe15b74be29f747fcb6206aee3">&#9670;&#160;</a></span>TsDeque() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a>&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac6c63aef2a6f9eab3021d4680c8c6e4" name="aac6c63aef2a6f9eab3021d4680c8c6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6c63aef2a6f9eab3021d4680c8c6e4">&#9670;&#160;</a></span>TsDeque() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a>&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. Using alloc as the allocator for the new container, moving the contents from other; if alloc != other.get_allocator(), this results in an element-wise move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2fff7e0c8999e1b500e24027c57556f" name="ab2fff7e0c8999e1b500e24027c57556f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fff7e0c8999e1b500e24027c57556f">&#9670;&#160;</a></span>TsDeque() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::TsDeque </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Alloc()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b35f9463dffbc0024519d030e454ce2" name="a9b35f9463dffbc0024519d030e454ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b35f9463dffbc0024519d030e454ce2">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with copies of those in the range [first, last). The behavior is undefined if either argument is an iterator into *this. </p>
<p>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first element of the range to copy the elements from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last element of the range to copy the elements from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b64f1d43706fc6b6cca3473a332d1e8" name="a5b64f1d43706fc6b6cca3473a332d1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b64f1d43706fc6b6cca3473a332d1e8">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list ilist. </p>
<p>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list to copy the values from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1be94f59bc1648c3796e2cc9b1ca6f03" name="a1be94f59bc1648c3796e2cc9b1ca6f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be94f59bc1648c3796e2cc9b1ca6f03">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with count copies of value value. </p>
<p>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>The value to initialize elements of the container with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5047f3cbaa74c124ad57763d12dd926a" name="a5047f3cbaa74c124ad57763d12dd926a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5047f3cbaa74c124ad57763d12dd926a">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type std::out_of_range is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="a7aabb4ac4badd7364c466a333a157ad8" name="a7aabb4ac4badd7364c466a333a157ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aabb4ac4badd7364c466a333a157ad8">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type std::out_of_range is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="a1b839d7218998c9be19292a8ae6d7418" name="a1b839d7218998c9be19292a8ae6d7418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b839d7218998c9be19292a8ae6d7418">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element </dd></dl>

</div>
</div>
<a id="a7b661a37731e6d908330d6c3567acc97" name="a7b661a37731e6d908330d6c3567acc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b661a37731e6d908330d6c3567acc97">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element </dd></dl>

</div>
</div>
<a id="a0a20f23f8b306b628c1a9fbf1854167f" name="a0a20f23f8b306b628c1a9fbf1854167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a20f23f8b306b628c1a9fbf1854167f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a3ebc66a0d8b5b36af158f638e7ae005d" name="a3ebc66a0d8b5b36af158f638e7ae005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc66a0d8b5b36af158f638e7ae005d">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="aeb65257d718177770c6e984ae1e5536d" name="aeb65257d718177770c6e984ae1e5536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb65257d718177770c6e984ae1e5536d">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator will be equal to <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a id="a9b45b9c1144dea9daca1501945c9ba9c" name="a9b45b9c1144dea9daca1501945c9ba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b45b9c1144dea9daca1501945c9ba9c">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a848429f5c9243e7ba1e8c0754d100baf" name="a848429f5c9243e7ba1e8c0754d100baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848429f5c9243e7ba1e8c0754d100baf">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements from the container. After this call, <a class="el" href="#a6fe145d9a286457bea3825b0ce34d722" title="Returns the number of elements in the container, i.e. std::distance(begin(), end()).">size()</a> returns zero. Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated. </p>

</div>
</div>
<a id="abafe1c3f2888cc0dcaf2ab27a2ca1227" name="abafe1c3f2888cc0dcaf2ab27a2ca1227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafe1c3f2888cc0dcaf2ab27a2ca1227">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="af56c0c4299bf1c5424ff0218dc303117" name="af56c0c4299bf1c5424ff0218dc303117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56c0c4299bf1c5424ff0218dc303117">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ac57f60eb6b8b1af75670ae82b95447b2" name="ac57f60eb6b8b1af75670ae82b95447b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f60eb6b8b1af75670ae82b95447b2">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container directly before pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the new element will be constructed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element. </dd></dl>

</div>
</div>
<a id="a1543910d3ec0189473a7143a65b5d55c" name="a1543910d3ec0189473a7143a65b5d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1543910d3ec0189473a7143a65b5d55c">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the inserted element. </dd></dl>

</div>
</div>
<a id="abbea375bf1b74058cd23ead6546a887d" name="abbea375bf1b74058cd23ead6546a887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbea375bf1b74058cd23ead6546a887d">&#9670;&#160;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element to the beginning of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the inserted element. </dd></dl>

</div>
</div>
<a id="ae3a05e1a6943bb88e7546be8e4695606" name="ae3a05e1a6943bb88e7546be8e4695606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a05e1a6943bb88e7546be8e4695606">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether '<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a> == <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>'. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise </dd></dl>

</div>
</div>
<a id="ae9f75120b51cd0c5a971961a8165771d" name="ae9f75120b51cd0c5a971961a8165771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f75120b51cd0c5a971961a8165771d">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ad5fb879559cb663986f4aab58e4d8a13" name="ad5fb879559cb663986f4aab58e4d8a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fb879559cb663986f4aab58e4d8a13">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the deque. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="aeb9697e748256d9a8b2ee43f7b8ef606" name="aeb9697e748256d9a8b2ee43f7b8ef606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9697e748256d9a8b2ee43f7b8ef606">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last). All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First element of the range of elements to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Last element of the range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="ae43754c6e04ad136086d50b2ba0611c1" name="ae43754c6e04ad136086d50b2ba0611c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43754c6e04ad136086d50b2ba0611c1">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="ad79acf8736f97723df0081a8610a376f" name="ad79acf8736f97723df0081a8610a376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79acf8736f97723df0081a8610a376f">&#9670;&#160;</a></span>extract_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::extract_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the first element in the container and removes it from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the first element </dd></dl>

</div>
</div>
<a id="abb005d6c17251ece8b9c4ad2835bd3ec" name="abb005d6c17251ece8b9c4ad2835bd3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb005d6c17251ece8b9c4ad2835bd3ec">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element </dd></dl>

</div>
</div>
<a id="a178dc03c9f4c0e95855e59bec49475f8" name="a178dc03c9f4c0e95855e59bec49475f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178dc03c9f4c0e95855e59bec49475f8">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element </dd></dl>

</div>
</div>
<a id="af6a1c1f027480466bf15561937943683" name="af6a1c1f027480466bf15561937943683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a1c1f027480466bf15561937943683">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T, Alloc &gt;::allocator_type <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="aa84eb1be1822ff509d78e70c35e5376f" name="aa84eb1be1822ff509d78e70c35e5376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84eb1be1822ff509d78e70c35e5376f">&#9670;&#160;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert value before pos in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a> iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value </dd></dl>

</div>
</div>
<a id="a35844694b10a63ba7d26367acee40314" name="a35844694b10a63ba7d26367acee40314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35844694b10a63ba7d26367acee40314">&#9670;&#160;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from range [first, last) before pos. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Input iterator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a> iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first element of the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last element of the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if first==last. </dd></dl>

</div>
</div>
<a id="a3364ffb541afb2a223c986f82989a08e" name="a3364ffb541afb2a223c986f82989a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3364ffb541afb2a223c986f82989a08e">&#9670;&#160;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer list ilist before pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a> iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>Initializer list to insert the values from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted, or pos if ilist is empty. </dd></dl>

</div>
</div>
<a id="a7eaa60b369f88913334fee7216c2bed7" name="a7eaa60b369f88913334fee7216c2bed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaa60b369f88913334fee7216c2bed7">&#9670;&#160;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert value before pos in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a> iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the inserted value </dd></dl>

</div>
</div>
<a id="ad343eee2f38da261ef3d10d6f050dc79" name="ad343eee2f38da261ef3d10d6f050dc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad343eee2f38da261ef3d10d6f050dc79">&#9670;&#160;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts count copies of the value before pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator before which the content will be inserted. pos may be the <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a> iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear in count plus linear in the lesser of the distances between pos and either of the ends of the container. </dd></dl>

</div>
</div>
<a id="aea171afc682e3a08588161e2a0843867" name="aea171afc682e3a08588161e2a0843867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea171afc682e3a08588161e2a0843867">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T, Alloc &gt;::size_type <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. std::distance(<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a>, <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>) for the largest container. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a id="a43fbf6fe3a38fa6a792e3f0f39edfa90" name="a43fbf6fe3a38fa6a792e3f0f39edfa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fbf6fe3a38fa6a792e3f0f39edfa90">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a> &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list to use as data source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6914fc1ff4b396561a3592460783b1b" name="ac6914fc1ff4b396561a3592460783b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6914fc1ff4b396561a3592460783b1b">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="a300be1eff93c23155acb254723923267" name="a300be1eff93c23155acb254723923267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300be1eff93c23155acb254723923267">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a id="a778844411c23c3d73076378e3109dc30" name="a778844411c23c3d73076378e3109dc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778844411c23c3d73076378e3109dc30">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. The new element is initialized as a copy of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the element to append </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe0492b2b65617d4d154fec0b9e8b74a" name="afe0492b2b65617d4d154fec0b9e8b74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0492b2b65617d4d154fec0b9e8b74a">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. Value is moved into the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the element to append </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a007912678085d5fb1ee75f6e7555770d" name="a007912678085d5fb1ee75f6e7555770d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007912678085d5fb1ee75f6e7555770d">&#9670;&#160;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the container. The new element is initialized as a copy of value. All iterators, including the past-the-end iterator, are invalidated. No references are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the element to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a747df6b5d743ccadd700b8278aee33c6" name="a747df6b5d743ccadd700b8278aee33c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747df6b5d743ccadd700b8278aee33c6">&#9670;&#160;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepends the given element value to the beginning of the container. Value is moved into the new element. All iterators, including the past-the-end iterator, are invalidated. No references are invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the element to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cacc4eaa6e8fa6ccd58429c5126e40d" name="a4cacc4eaa6e8fa6ccd58429c5126e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cacc4eaa6e8fa6ccd58429c5126e40d">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="a25ca6b19069d2677fa95c39750acdd5d" name="a25ca6b19069d2677fa95c39750acdd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ca6b19069d2677fa95c39750acdd5d">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed deque. It corresponds to the last element of the non-reversed deque. If the deque is empty, the returned iterator is equal to <a class="el" href="#a18418e08e214ac9ccabe7ee0a59411dd" title="Returns a reverse iterator to the element following the last element of the reversed deque....">rend()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a id="a7c83700b495b7512b8a059647d3e2847" name="a7c83700b495b7512b8a059647d3e2847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c83700b495b7512b8a059647d3e2847">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::const_reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a18418e08e214ac9ccabe7ee0a59411dd" name="a18418e08e214ac9ccabe7ee0a59411dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18418e08e214ac9ccabe7ee0a59411dd">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt;::reverse_iterator <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed deque. It corresponds to the element preceding the first element of the non-reversed deque. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a30474793b611d738230ffa00a90fe2f8" name="a30474793b611d738230ffa00a90fe2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30474793b611d738230ffa00a90fe2f8">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>New size of the container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4515d81a5c7f996d3526f8469b70346e" name="a4515d81a5c7f996d3526f8469b70346e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4515d81a5c7f996d3526f8469b70346e">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">typename std::deque&lt; T, Alloc &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain count elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>New size of the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to initialize the new elements with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fe145d9a286457bea3825b0ce34d722" name="a6fe145d9a286457bea3825b0ce34d722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe145d9a286457bea3825b0ce34d722">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T, Alloc &gt;::size_type <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. std::distance(<a class="el" href="#a3ebc66a0d8b5b36af158f638e7ae005d" title="Returns an iterator to the first element of the deque. If the deque is empty, the returned iterator w...">begin()</a>, <a class="el" href="#ad5fb879559cb663986f4aab58e4d8a13" title="Returns an iterator to the element following the last element of the deque. This element acts as a pl...">end()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="a6b04a5077600e9355e35e5b40f025241" name="a6b04a5077600e9355e35e5b40f025241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b04a5077600e9355e35e5b40f025241">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classNAV_1_1TsDeque.html">NAV::TsDeque</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>Container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/INSTINCT/INSTINCT/src/util/Container/<a class="el" href="TsDeque_8hpp_source.html">TsDeque.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>NAV</b></li><li class="navelem"><a class="el" href="classNAV_1_1TsDeque.html">TsDeque</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
